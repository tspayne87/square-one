import { Specification, SpecificationToken, ISpecificationTokenGroup } from '../../Specification';
import { Token } from '../../lexor';

const ops = [ '$and', '$or', '$nor' ];

/**
 * Helper interface to build out a key value pairing.
 */
interface IKeyValuePair {
    key: string;
    value: any;
}

/**
 * Override the query method on the specification class so that we will use this to gernerate the mongoose query.
 */
Specification.prototype.query = function() {
    return generateQuery((<any>this).tokens, this.vars);
};

/**
 * Helper function that will recursivly build out the mongoose query.
 * 
 * @param tokens The tokens that need to be parsed into a mongoose query.
 * @param vars The variables that can be used in the query.
 */
function generateQuery(tokens: SpecificationToken[], vars?: { [key: string]: any }) {
    if (tokens.length === 1) {
        let token = tokens[0];
        if (Array.isArray(token)) {
            return generateQuery(token, vars);
        } else {
            return combineFields({ $and: [ generateField(token, vars) ] });
        }
    } else {
        let result: any = {};
        let op: string = Array.isArray(tokens[1]) ? '$and' : getOperator((<ISpecificationTokenGroup>tokens[1]).op);
        for (let i = 0; i < tokens.length; i += 2) {
            let token = tokens[i];
            let opToken = <ISpecificationTokenGroup>tokens[i - 1];
            let curOp = opToken === undefined ? op : getOperator(opToken.op);

            if (curOp !== op) throw 'Please wrap logical operations that are not the same with parentheses';
            result[op] = result[op] || [];

            if (Array.isArray(token)) {
                let query = generateQuery(token, vars);
                if (curOp !== op) query = { $or: [ query ] };
                result[op].push(query);
            } else {
                if (token.op.type === 'not' && token.left === undefined && token.right === undefined && Array.isArray(tokens[i + 1])) {
                    let query = generateQuery(<SpecificationToken[]>tokens[++i], vars);
                    if (query['$or'] !== undefined) {
                        result[op].push({ $and: negateOr(query['$or']) });
                    } else if (query['$and'] !== undefined) {
                        result[op].push({ $nor: query['$and'] });
                    }
                } else {
                    let field = generateField(token, vars);
                    if (curOp !== op) field = { $or: [ field ] };
                    result[op].push(field);
                }
            }
        }

        condenseLogicalQueryOperators(result);
        return combineFields(result);
    }
}

/**
 * Helper function is meant to condense the query down to something that is easy for mongoose to use.
 * 
 * @param query The current mongoose query that was generated.
 */
function condenseLogicalQueryOperators(query: any) {
    for (let i = 0; i < ops.length; ++i) {
        let op = ops[i];
        if (query[op]) {
            for (let j = 0; j < query[op].length; ++j) {
                if (query[op][j][op]) {
                    let combine = query[op][j][op];
                    query[op].splice(j, 1);
                    query[op] = query[op].concat(combine);
                }
            }
        }
    }
}

/**
 * Function is meant to condense the query if it can down to a query that would be generated by a person
 * instead of an auto-generator.  Sanity function to make sure the query given back is as clean as possible
 * for mongoose.
 * 
 * @param query The Query Object we need to combine some fields to make the query easier to read and for mongoose.
 */
function combineFields(query: any) {
    if (query['$and'] && query['$and'].findIndex((item) => checkIfHasOperator(item)) === -1) {
        // If we are dealing with a basic and query and the object does not have any logical operators than we should
        // try to make the query simplier
        let newQuery: any = {};
        for (let i = 0; i < query['$and'].length; ++i) {
            let field = query['$and'][i];
            let keys = Object.keys(field);
            for (let j = 0; j < keys.length; ++j) {
                if (typeof field[keys[j]] === 'object') {
                    newQuery[keys[j]] = newQuery[keys[j]] || {};
                    let opKeys = Object.keys(field[keys[j]]);
                    for (let k = 0; k < opKeys.length; ++k) {
                        newQuery[keys[j]][opKeys[k]] = field[keys[j]][opKeys[k]];
                    }
                } else {
                    newQuery[keys[j]] = field[keys[j]];
                }
            }
        }
        let keys = Object.keys(newQuery);
        for (let i = 0; i < keys.length; ++i) {
            let opKeys = Object.keys(newQuery[keys[i]]);
            if (opKeys.length === 1 && opKeys[0] === '$eq') {
                newQuery[keys[i]] = newQuery[keys[i]]['$eq'];
            }
        }
        return newQuery;
    } else if (query['$and']) {
        cleanEquals(query['$and']);
    } else if (query['$or']) {
        // Handle equality for or clause if we have two of the same elements in a where clause
        // we need to condense the values and create an '$in' expression for mongo to handle easier
        let groups = groupBy(query['$or'], (item) => Object.keys(item).join(','));
        let keys = Object.keys(groups);
        for (let i = 0; i < keys.length; ++i) {
            let pairs: IKeyValuePair[] = groups[keys[i]].reduce((arr, x) => arr.concat(toKeyValuePair(x[keys[i]])), []);
            let pairGroups = groupBy(pairs, x => x.key);
            if (pairGroups['$eq'] && pairGroups['$in']) {
                for (let j = 0; j < pairGroups['$eq'].length; ++j) {
                    pairGroups['$in'].push(pairGroups['$eq'][j].value);
                }
            } else if (pairGroups['$eq'] && pairGroups['$eq'].length > 1) {
                let arr: any[] = [];
                for (let j = 0; j < pairGroups['$eq'].length; ++j) {
                    arr.push(pairGroups['$eq'][j].value);
                }
                query['$or'].push({ [keys[i]]: { $in: arr } });

                let index = query['$or'].findIndex(x => x[keys[i]]);
                let readd: any[] = [];
                while (index > -1) {
                    if (query['$or'][index][keys[i]]['$eq']) {
                        if (Object.keys(query['$or'][index][keys[i]]).length === 1) {
                            delete query['$or'][index][keys[i]]['$eq'];
                        }
                        if (Object.keys(query['$or'][index]).length === 1) {
                            query['$or'].splice(index, 1);
                        }
                    } else {
                        readd = readd.concat(query['$or'].splice(index, 1));
                    }
                    index = query['$or'].findIndex(x => x[keys[i]]);
                }
                query['$or'] = query['$or'].concat(readd);
            }
        }

        if (query['$or'].length === 1) {
            return query['$or'][0];
        } else {
            cleanEquals(query['$or']);
        }
    }
    return query;
}

/**
 * Helper method that will remove the $eq operator if it is only operator and will replace it with the equal
 * shortcut.
 * 
 * @param list The list that needs to be cleaned.
 */
function cleanEquals(list: any[]) {
    for (let i = 0; i < list.length; ++i) {
        let keys = Object.keys(list[i]);
        if (keys.length === 1 && list[i][keys[0]]['$eq']) {
            list[i][keys[0]] = list[i][keys[0]]['$eq'];
        }
    }
}

/**
 * Helper function to generate a key value pair form the object.
 * 
 * @param obj The object the key value pair needs to be generated from.
 */
function toKeyValuePair(obj): IKeyValuePair[] {
    let result: IKeyValuePair[] = [];
    let keys = Object.keys(obj);
    for (let i = 0; i < keys.length; ++i) {
        result.push({ key: keys[i], value: obj[keys[i]] });
    }
    return result;
}

/**
 * Helper function that will generate a group by array based on the key callback.
 * 
 * @param arr The array that needs to be grouped on.
 * @param keyCallback The key callback that should be used.
 */
function groupBy<T>(arr: T[], keyCallback: (item: T) => string) {
    return arr.reduce((rv, x) => {
        let key = keyCallback(x);
        (rv[key] = rv[key] || []).push(x);
        return rv;
    }, {});
}

/**
 * Helper function that will determine if it has logical operators in the query.
 * 
 * @param item The item that needs to be checked.
 */
function checkIfHasOperator(item) {
    for (let i = 0; i < ops.length; ++i) {
        if (item[ops[i]]) return true;
    }
    return false;
}

/**
 * Helper method that will negate a query recursivly.
 * 
 * @param query The query that needs to be negated.
 */
function negateOr(query: any[]) {
    let result: any[] = [];
    for (let i = 0; i < query.length; ++i) {
        if (query[i]['$and']) {
            result.push({ $nor: query[i]['$and'] });
        } else if (query[i]['$or']) {
            result.push({ $and: negateOr(query[i]['$or']) });
        } else if (query[i]['$nor']) {
            result.push({ $and: query[i]['$nor'] });
        } else {
            let keys = Object.keys(query[i]);
            let field: any = {};
            for (let j = 0; j < keys.length; ++j) {
                let opKeys = Object.keys(query[i][keys[j]]);
                let operators: any = {};
                for (let k = 0; k < opKeys.length; ++k) {
                    let val = query[i][keys[j]][opKeys[k]];
                    switch (opKeys[k]) {
                        case '$eq':
                            operators['$ne'] = val;
                            break;
                        case '$gt':
                            operators['$lt'] = val;
                            break;
                        case '$gte':
                            operators['$lte'] = val;
                            break;
                        case '$in':
                            operators['$nin'] = val;
                            break;
                        case '$lt':
                            operators['$gt'] = val;
                            break;
                        case '$lte':
                            operators['$gte'] = val;
                            break;
                        case '$ne':
                        case '$not':
                            operators['$eq'] = val;
                            break;
                        case '$nin':
                            operators['$in'] = val;
                            break;
                    }
                }
                field[keys[j]] = operators;
            }
            result.push(field);
        }
    }
    return result;
}

/**
 * Helper function that will generate a query field from the token given.
 * 
 * @param token The token that the field should be generated from.
 * @param vars The variables that should be used.
 */
function generateField(token: ISpecificationTokenGroup, vars?: { [key: string]: any }): any {
    if (token.left === undefined || token.left.type !== 'ref') throw 'value to value comparison is not allowed.';
    let op = token.op === undefined ? '$eq' : getOperator(token.op);
    return { [token.left.value]: { [op]: getValue(token.right, vars) } };
}

/**
 * Helper function that will generate the value from the token given.
 * 
 * @param token The token that the value needs to be gathered from.
 * @param vars The variables that should be used.
 */
function getValue(token?: Token, vars?: { [key: string]: any }): any {
    if (token !== undefined) {
        if (token.type === 'ref') return `$${token.value}`;
        if (token.type === 'val') return token.value;
        if (token.type === 'var') {
            if (!vars) throw 'Variables need to be passed in if you want to use the variable feature';
            if (vars && !vars.hasOwnProperty(token.value)) throw 'Variable could not be found for use in the spec';
            return vars[token.value] || null;
        }
    }
    return undefined;
}

/**
 * Helper function that will generate the operator that should be used for the token given.
 * 
 * @param op The token the operator needs to be generated from.
 */
function getOperator(op: Token): string {
    switch (op.type) {
        case 'and': return '$and';
        case 'or': return '$or';
        case 'gt': return '$gt';
        case 'gte': return '$gte';
        case 'lt': return '$lt';
        case 'lte': return '$lte';
        case 'ne': return '$ne';
        case 'eq': return '$eq';
        case 'not': return '$not';
    }
    throw `Operator [${op.type}] could not be generated`;
}